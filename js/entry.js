import * as THREE from 'three';

import globals from './globals';
import variables from './variables';

import { setupRenderTargets } from './renderTargets';

import { simulationUniforms, displayUniforms } from './uniforms';
import { simulationMaterial, displayMaterial } from './materials';

let canvas, bufferCanvas, renderer, camera, scene, mesh;

setup();
update();

//==============================================================
//  SETUP (scene, camera, display mesh, etc)
//  - ThreeJS needs a few fundamental elements in order to
//    display something on the screen: a camera, a renderer,
//    and a scene containing one or more meshes.
//  - In this sketch, we're creating a flat plane and orienting
//    it perpendicular to the camera, taking up the entire
//    viewing area (the screen). The reaction-diffusion output
//    is rendered to this mesh as a texture, making it look
//    perfectly 2D.
//==============================================================
function setup() {
  // Set up the camera and scene
  camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  scene = new THREE.Scene();

  // Create a plane and orient it perpendicular to the camera so it seems 2D
  mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2), displayMaterial);
  scene.add(mesh);

  // Set up the renderer (a WebGL context inside a <canvas>)
  renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true });
  renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
  renderer.setSize(variables.canvas.width.value, variables.canvas.height.value);

  // Uncomment this line to see how many shader varyings your GPU supports.
  // console.log(renderer.capabilities.maxVaryings);

  canvas = renderer.domElement;

  // Grab the container DOM element and inject the <canvas> element generated by the renderer
  document.getElementById('container').appendChild(canvas);

  // Update the renderer dimensions whenever the browser is resized
  window.addEventListener('resize', resetTextureSizes, false);
  resetTextureSizes();

  // Set up and render the first frame
  // drawFirstFrame();
}

  export function resetTextureSizes() {
    variables.canvas.width.value = canvas.clientWidth;
    variables.canvas.height.value = canvas.clientHeight;

    // Resize render targets
    setupRenderTargets();

    // Reset the resolution in the simulation code to match new container size
    simulationUniforms.resolution.value = new THREE.Vector2(
      variables.canvas.width.value * variables.scale.value,
      variables.canvas.height.value * variables.scale.value
    );

    // Resize the buffer canvas
    bufferCanvas = document.querySelector('#buffer-canvas');
    bufferCanvas.width = variables.canvas.width.value;
    bufferCanvas.height = variables.canvas.height.value;
  }


//==============================================================
//  UPDATE
//  - Main program loop, runs once per frame no matter what.
//==============================================================
function update() {
  if(!globals.isPaused) {
    // Activate the simulation shaders
    mesh.material = simulationMaterial;

    // Run the simulation multiple times by feeding the result of one iteration (a render target's texture) into the next render target
    for(let i=0; i<globals.pingPongSteps; i++) {
      let nextRenderTargetIndex = globals.currentRenderTargetIndex === 0 ? 1 : 0;

      simulationUniforms.previousGenerationStates.value = renderTargets[globals.currentRenderTargetIndex].texture;  // grab the result of the last iteration
      renderer.setRenderTarget(renderTargets[nextRenderTargetIndex]);                                               // prepare to render into the next render target
      renderer.render(scene, camera);                                                                               // run the simulation shader on that texture
      simulationUniforms.previousGenerationStates.value = renderTargets[nextRenderTargetIndex].texture;             // save the result of this simulation step for use in the next step
      displayUniforms.previousGenerationStates.value = renderTargets[nextRenderTargetIndex].texture;                // pass this result to the display material too

      globals.currentRenderTargetIndex = nextRenderTargetIndex;
    }

    // Activate the display shaders
    displayUniforms.time.value = globals.clock.getElapsedTime();
    mesh.material = displayMaterial;

    // Render the latest iteration to the screen
    renderer.setRenderTarget(null);
    renderer.render(scene, camera);
  }

  // Run again when the next frame starts
  requestAnimationFrame(update);
}