import * as THREE from 'three';

import globals from './globals';
import variables from './variables';

import { setupRenderTargets, renderTargets } from './renderTargets';

import { simulationUniforms, displayUniforms } from './uniforms';
import { simulationMaterial, displayMaterial } from './materials';
import { drawPattern } from './patterns';

export let scene, camera, renderer, mesh;

let canvas, bufferCanvas;

setup();
update();

//==============================================================
//  SETUP (scene, camera, display mesh, etc)
//  - ThreeJS needs a few fundamental elements in order to
//    display something on the screen: a camera, a renderer,
//    and a scene containing one or more meshes.
//  - In this sketch, we're creating a flat plane and orienting
//    it perpendicular to the camera, taking up the entire
//    viewing area (the screen). The reaction-diffusion output
//    is rendered to this mesh as a texture, making it look
//    perfectly 2D.
//==============================================================
function setup() {
  // Set up the camera and scene
  camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  scene = new THREE.Scene();

  // Create a plane and orient it perpendicular to the camera so it seems 2D
  mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2), displayMaterial);
  scene.add(mesh);

  // Set up the renderer (a WebGL context inside a <canvas>)
  renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true });
  renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
  renderer.setSize(variables.canvas.width.value, variables.canvas.height.value);

  // Uncomment this line to see how many shader varyings your GPU supports.
  // console.log(renderer.capabilities.maxVaryings);

  canvas = renderer.domElement;

  // Grab the container DOM element and inject the <canvas> element generated by the renderer
  document.getElementById('container').appendChild(canvas);

  // Update the renderer dimensions whenever the browser is resized
  window.addEventListener('resize', resetTextureSizes, false);
  resetTextureSizes();

  // Set up and render the first frame
  drawPattern();

  // Create birth and survival rules as a texture
  let data = new Float32Array(2 * 1 * 4);
  data[0] = 3 / 255;  // birth ([0,0].r)
  data[1] = 2 / 255;  // survive ([0,0].g)
  data[5] = 3 / 255;  // survive ([1,0].g)

  simulationUniforms.birthAndSurvivalCounts.value = new THREE.DataTexture(data, 2, 1, THREE.RGBAFormat, THREE.FloatType);

  // Start the simulation on Space for debugging
  window.addEventListener('keyup', (e) => {
    if(e.key == ' ') {
      globals.isPaused = false;
    }
  });
}

  export function resetTextureSizes() {
    variables.canvas.width.value = canvas.clientWidth;
    variables.canvas.height.value = canvas.clientHeight;

    // Resize render targets
    setupRenderTargets();

    // Reset the resolution in the simulation code to match new container size
    simulationUniforms.resolution.value = new THREE.Vector2(
      variables.canvas.width.value,
      variables.canvas.height.value
    );

    // Resize the buffer canvas
    bufferCanvas = document.querySelector('#buffer-canvas');
    bufferCanvas.width = variables.canvas.width.value;
    bufferCanvas.height = variables.canvas.height.value;
  }


//==============================================================
//  UPDATE
//  - Main program loop, runs once per frame no matter what.
//==============================================================
function update() {
  if(!globals.isPaused) {
    // Activate the simulation shaders
    mesh.material = simulationMaterial;

    // Run the simulation multiple times by feeding the result of one iteration (a render target's texture) into the next render target
    for(let i=0; i<globals.pingPongSteps; i++) {
      let nextRenderTargetIndex = globals.currentRenderTargetIndex === 0 ? 1 : 0;

      simulationUniforms.states.value = renderTargets[globals.currentRenderTargetIndex].texture;  // grab the result of the last iteration
      renderer.setRenderTarget(renderTargets[nextRenderTargetIndex]);                             // prepare to render into the next render target
      renderer.render(scene, camera);                                                             // run the simulation shader on that texture

      globals.currentRenderTargetIndex = nextRenderTargetIndex;
    }

    // Activate the display shaders
    displayUniforms.time.value = globals.clock.getElapsedTime();
    displayUniforms.textureToDisplay.value = renderTargets[globals.currentRenderTargetIndex].texture;  // pass this result to the display material too
    mesh.material = displayMaterial;

    // Render the latest iteration to the screen
    renderer.setRenderTarget(null);
    renderer.render(scene, camera);

    // globals.isPaused = true;
  }

  // Run again when the next frame starts
  requestAnimationFrame(update);
}